        - 
        - module Fourdfp
        - 
        - using Chain
        - 
        - @enum ByteOrder LittleEndian BigEndian
        - export LittleEndian, BigEndian
        - 
        - "Trim off .4dfp.* file extension, if any, from a filename"
       12 get_imgroot(filename::String) = replace(filename, r".4dfp.(ifh|hdr|img(.rec)?)$" => "")
        - 
        - "The 'matrix size' lines in a .4dfp.ifh file gives the size of each data dimension"
        6 function get_dims(filename::String)::Vector{Int}
        6 	@chain begin
        6 		"$(get_imgroot(filename)).4dfp.ifh"
        - 		readlines
      192 		filter(x -> !isnothing(match(r"^matrix size", x)), _)
       12 		replace.(_, r".* ([0-9]+)" => s"\1")
        6 		parse.(Int, _)
        - 	end
        - end
        - 
        2 function get_endianness(filename::String)::ByteOrder
        2 	endianness =
        - 		@chain begin
        2 			"$(Fourdfp.get_imgroot(filename)).4dfp.ifh"
        - 			readlines
       57 			filter(x -> !isnothing(match(r"^imagedata byte order", x)), _)
        4 			replace.(_, r".*:= (\w+)" => s"\1")
        - 		end
        2 	if length(endianness) == 1 && endianness[1] in ("littleendian", "bigendian")
        1 		return endianness[1] == "littleendian" ? LittleEndian : BigEndian
        - 	else
        1 		error("Byte order (endianness) could not be parsed from ifh file for $filename")
        - 	end
        - end
        - 
        - """
        - 	 load(filename; byte_order)
        - 
        - A simple 4dfp-reading function.
        - 
        - Filename sould be the path of a 4dfp file, optionally omitting the file extension.
        - 
        - Byte order should be one of LittleEndian or BigEndian; or omit this argument
        - and the function will attempt to parse the byte order from the .4dfp.ifh file.
        - """
        8 function load(filename::String; byte_order::Union{Nothing, ByteOrder} = nothing)
        4 	imgroot = get_imgroot(filename)
        4 	dims = get_dims(imgroot)
        4 	dtype = Float32
        4 	dsize = sizeof(dtype)
        8 	nvoxels = prod(dims[1:3])
        8 	nframes = length(dims) < 4 ? 1 : dims[4]
        4 	bytes_per_frame = dsize * nvoxels
        4 	bytes_to_read = nframes * bytes_per_frame
        4 	temp = zeros(UInt8, bytes_to_read)
        4 	open("$imgroot.4dfp.img", "r") do fid
        4 		readbytes!(fid, temp, bytes_to_read)
        - 	end
        4 	if isnothing(byte_order) 
        2 		byte_order = get_endianness(filename)
        - 	end
        3 	byte_order_fn = byte_order == LittleEndian ? ltoh : ntoh
        3 	@chain reinterpret(dtype, temp) byte_order_fn.(_) reshape(_, dims...)
        - end
        - 
        - end
        - 
